# Generated from FinalStatePattern.g4 by ANTLR 4.5.2
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3")
        buf.write(u"\fw\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4")
        buf.write(u"\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write(u"\t\16\4\17\t\17\3\2\3\2\3\2\6\2\"\n\2\r\2\16\2#\3\3\3")
        buf.write(u"\3\5\3(\n\3\3\4\3\4\3\5\3\5\3\5\3\5\3\5\5\5\61\n\5\3")
        buf.write(u"\6\3\6\3\6\3\6\3\6\3\6\5\69\n\6\3\7\3\7\3\b\3\b\3\b\7")
        buf.write(u"\b@\n\b\f\b\16\bC\13\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3")
        buf.write(u"\t\3\t\3\t\5\tO\n\t\3\n\3\n\3\n\5\nT\n\n\3\13\3\13\3")
        buf.write(u"\13\3\13\3\13\7\13[\n\13\f\13\16\13^\13\13\5\13`\n\13")
        buf.write(u"\3\13\3\13\3\f\3\f\5\ff\n\f\3\r\3\r\3\r\3\r\3\r\3\r\5")
        buf.write(u"\rn\n\r\3\16\3\16\3\16\5\16s\n\16\3\17\3\17\3\17\2\2")
        buf.write(u"\20\2\4\6\b\n\f\16\20\22\24\26\30\32\34\2\2v\2!\3\2\2")
        buf.write(u"\2\4\'\3\2\2\2\6)\3\2\2\2\b\60\3\2\2\2\n8\3\2\2\2\f:")
        buf.write(u"\3\2\2\2\16<\3\2\2\2\20N\3\2\2\2\22S\3\2\2\2\24U\3\2")
        buf.write(u"\2\2\26e\3\2\2\2\30m\3\2\2\2\32r\3\2\2\2\34t\3\2\2\2")
        buf.write(u"\36\37\5\4\3\2\37 \7\n\2\2 \"\3\2\2\2!\36\3\2\2\2\"#")
        buf.write(u"\3\2\2\2#!\3\2\2\2#$\3\2\2\2$\3\3\2\2\2%(\5\b\5\2&(\5")
        buf.write(u"\6\4\2\'%\3\2\2\2\'&\3\2\2\2(\5\3\2\2\2)*\5\20\t\2*\7")
        buf.write(u"\3\2\2\2+\61\5\n\6\2,-\5\n\6\2-.\7\13\2\2./\5\16\b\2")
        buf.write(u"/\61\3\2\2\2\60+\3\2\2\2\60,\3\2\2\2\61\t\3\2\2\2\62")
        buf.write(u"9\7\7\2\2\63\64\7\7\2\2\64\65\7\3\2\2\65\66\5\f\7\2\66")
        buf.write(u"\67\7\4\2\2\679\3\2\2\28\62\3\2\2\28\63\3\2\2\29\13\3")
        buf.write(u"\2\2\2:;\7\7\2\2;\r\3\2\2\2<A\5\20\t\2=>\7\5\2\2>@\5")
        buf.write(u"\20\t\2?=\3\2\2\2@C\3\2\2\2A?\3\2\2\2AB\3\2\2\2B\17\3")
        buf.write(u"\2\2\2CA\3\2\2\2DE\5\22\n\2EF\7\t\2\2FG\5\22\n\2GO\3")
        buf.write(u"\2\2\2HI\5\32\16\2IJ\7\t\2\2JK\5\30\r\2KL\7\t\2\2LM\5")
        buf.write(u"\32\16\2MO\3\2\2\2ND\3\2\2\2NH\3\2\2\2O\21\3\2\2\2PT")
        buf.write(u"\5\32\16\2QT\5\30\r\2RT\5\24\13\2SP\3\2\2\2SQ\3\2\2\2")
        buf.write(u"SR\3\2\2\2T\23\3\2\2\2UV\7\7\2\2V_\7\3\2\2W\\\5\26\f")
        buf.write(u"\2XY\7\5\2\2Y[\5\26\f\2ZX\3\2\2\2[^\3\2\2\2\\Z\3\2\2")
        buf.write(u"\2\\]\3\2\2\2]`\3\2\2\2^\\\3\2\2\2_W\3\2\2\2_`\3\2\2")
        buf.write(u"\2`a\3\2\2\2ab\7\4\2\2b\25\3\2\2\2cf\5\30\r\2df\5\20")
        buf.write(u"\t\2ec\3\2\2\2ed\3\2\2\2f\27\3\2\2\2gn\7\7\2\2hn\5\n")
        buf.write(u"\6\2ij\5\n\6\2jk\7\6\2\2kl\7\7\2\2ln\3\2\2\2mg\3\2\2")
        buf.write(u"\2mh\3\2\2\2mi\3\2\2\2n\31\3\2\2\2os\7\b\2\2pq\7\b\2")
        buf.write(u"\2qs\5\34\17\2ro\3\2\2\2rp\3\2\2\2s\33\3\2\2\2tu\7\7")
        buf.write(u"\2\2u\35\3\2\2\2\16#\'\608ANS\\_emr")
        return buf.getvalue()


class FinalStatePatternParser ( Parser ):

    grammarFileName = "FinalStatePattern.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"'('", u"')'", u"','", u"'.'", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"';'", u"':'" ]

    symbolicNames = [ u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"NAME", u"NUMBER", u"BINARY_OP", u"LEOF", 
                      u"COLON", u"WS" ]

    RULE_top_level = 0
    RULE_line_needing_eof = 1
    RULE_standalone_cut = 2
    RULE_object_specification = 3
    RULE_object_name = 4
    RULE_base_definition = 5
    RULE_cut_list = 6
    RULE_cut = 7
    RULE_cut_arg = 8
    RULE_function = 9
    RULE_function_arg = 10
    RULE_cut_name = 11
    RULE_cut_number = 12
    RULE_unit = 13

    ruleNames =  [ u"top_level", u"line_needing_eof", u"standalone_cut", 
                   u"object_specification", u"object_name", u"base_definition", 
                   u"cut_list", u"cut", u"cut_arg", u"function", u"function_arg", 
                   u"cut_name", u"cut_number", u"unit" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    NAME=5
    NUMBER=6
    BINARY_OP=7
    LEOF=8
    COLON=9
    WS=10

    def __init__(self, input):
        super(FinalStatePatternParser, self).__init__(input)
        self.checkVersion("4.5.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class Top_levelContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FinalStatePatternParser.Top_levelContext, self).__init__(parent, invokingState)
            self.parser = parser

        def line_needing_eof(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FinalStatePatternParser.Line_needing_eofContext)
            else:
                return self.getTypedRuleContext(FinalStatePatternParser.Line_needing_eofContext,i)


        def LEOF(self, i=None):
            if i is None:
                return self.getTokens(FinalStatePatternParser.LEOF)
            else:
                return self.getToken(FinalStatePatternParser.LEOF, i)

        def getRuleIndex(self):
            return FinalStatePatternParser.RULE_top_level

        def enterRule(self, listener):
            if hasattr(listener, "enterTop_level"):
                listener.enterTop_level(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTop_level"):
                listener.exitTop_level(self)




    def top_level(self):

        localctx = FinalStatePatternParser.Top_levelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_top_level)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 31 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 28
                self.line_needing_eof()
                self.state = 29
                self.match(FinalStatePatternParser.LEOF)
                self.state = 33 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==FinalStatePatternParser.NAME or _la==FinalStatePatternParser.NUMBER):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Line_needing_eofContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FinalStatePatternParser.Line_needing_eofContext, self).__init__(parent, invokingState)
            self.parser = parser

        def object_specification(self):
            return self.getTypedRuleContext(FinalStatePatternParser.Object_specificationContext,0)


        def standalone_cut(self):
            return self.getTypedRuleContext(FinalStatePatternParser.Standalone_cutContext,0)


        def getRuleIndex(self):
            return FinalStatePatternParser.RULE_line_needing_eof

        def enterRule(self, listener):
            if hasattr(listener, "enterLine_needing_eof"):
                listener.enterLine_needing_eof(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLine_needing_eof"):
                listener.exitLine_needing_eof(self)




    def line_needing_eof(self):

        localctx = FinalStatePatternParser.Line_needing_eofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_line_needing_eof)
        try:
            self.state = 37
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 35
                self.object_specification()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 36
                self.standalone_cut()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Standalone_cutContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FinalStatePatternParser.Standalone_cutContext, self).__init__(parent, invokingState)
            self.parser = parser

        def cut(self):
            return self.getTypedRuleContext(FinalStatePatternParser.CutContext,0)


        def getRuleIndex(self):
            return FinalStatePatternParser.RULE_standalone_cut

        def enterRule(self, listener):
            if hasattr(listener, "enterStandalone_cut"):
                listener.enterStandalone_cut(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitStandalone_cut"):
                listener.exitStandalone_cut(self)




    def standalone_cut(self):

        localctx = FinalStatePatternParser.Standalone_cutContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_standalone_cut)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 39
            self.cut()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Object_specificationContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FinalStatePatternParser.Object_specificationContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FinalStatePatternParser.RULE_object_specification

     
        def copyFrom(self, ctx):
            super(FinalStatePatternParser.Object_specificationContext, self).copyFrom(ctx)



    class ObjectSpecNameAndCutListContext(Object_specificationContext):

        def __init__(self, parser, ctx): # actually a FinalStatePatternParser.Object_specificationContext)
            super(FinalStatePatternParser.ObjectSpecNameAndCutListContext, self).__init__(parser)
            self.copyFrom(ctx)

        def object_name(self):
            return self.getTypedRuleContext(FinalStatePatternParser.Object_nameContext,0)

        def COLON(self):
            return self.getToken(FinalStatePatternParser.COLON, 0)
        def cut_list(self):
            return self.getTypedRuleContext(FinalStatePatternParser.Cut_listContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterObjectSpecNameAndCutList"):
                listener.enterObjectSpecNameAndCutList(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitObjectSpecNameAndCutList"):
                listener.exitObjectSpecNameAndCutList(self)


    class ObjectSpecNameOnlyContext(Object_specificationContext):

        def __init__(self, parser, ctx): # actually a FinalStatePatternParser.Object_specificationContext)
            super(FinalStatePatternParser.ObjectSpecNameOnlyContext, self).__init__(parser)
            self.copyFrom(ctx)

        def object_name(self):
            return self.getTypedRuleContext(FinalStatePatternParser.Object_nameContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterObjectSpecNameOnly"):
                listener.enterObjectSpecNameOnly(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitObjectSpecNameOnly"):
                listener.exitObjectSpecNameOnly(self)



    def object_specification(self):

        localctx = FinalStatePatternParser.Object_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_object_specification)
        try:
            self.state = 46
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                localctx = FinalStatePatternParser.ObjectSpecNameOnlyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 41
                self.object_name()
                pass

            elif la_ == 2:
                localctx = FinalStatePatternParser.ObjectSpecNameAndCutListContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 42
                self.object_name()
                self.state = 43
                self.match(FinalStatePatternParser.COLON)
                self.state = 44
                self.cut_list()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Object_nameContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FinalStatePatternParser.Object_nameContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(FinalStatePatternParser.NAME, 0)

        def base_definition(self):
            return self.getTypedRuleContext(FinalStatePatternParser.Base_definitionContext,0)


        def getRuleIndex(self):
            return FinalStatePatternParser.RULE_object_name

        def enterRule(self, listener):
            if hasattr(listener, "enterObject_name"):
                listener.enterObject_name(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitObject_name"):
                listener.exitObject_name(self)




    def object_name(self):

        localctx = FinalStatePatternParser.Object_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_object_name)
        try:
            self.state = 54
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 48
                self.match(FinalStatePatternParser.NAME)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 49
                self.match(FinalStatePatternParser.NAME)
                self.state = 50
                self.match(FinalStatePatternParser.T__0)
                self.state = 51
                self.base_definition()
                self.state = 52
                self.match(FinalStatePatternParser.T__1)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Base_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FinalStatePatternParser.Base_definitionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(FinalStatePatternParser.NAME, 0)

        def getRuleIndex(self):
            return FinalStatePatternParser.RULE_base_definition

        def enterRule(self, listener):
            if hasattr(listener, "enterBase_definition"):
                listener.enterBase_definition(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBase_definition"):
                listener.exitBase_definition(self)




    def base_definition(self):

        localctx = FinalStatePatternParser.Base_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_base_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 56
            self.match(FinalStatePatternParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Cut_listContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FinalStatePatternParser.Cut_listContext, self).__init__(parent, invokingState)
            self.parser = parser

        def cut(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FinalStatePatternParser.CutContext)
            else:
                return self.getTypedRuleContext(FinalStatePatternParser.CutContext,i)


        def getRuleIndex(self):
            return FinalStatePatternParser.RULE_cut_list

        def enterRule(self, listener):
            if hasattr(listener, "enterCut_list"):
                listener.enterCut_list(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCut_list"):
                listener.exitCut_list(self)




    def cut_list(self):

        localctx = FinalStatePatternParser.Cut_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_cut_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 58
            self.cut()
            self.state = 63
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==FinalStatePatternParser.T__2:
                self.state = 59
                self.match(FinalStatePatternParser.T__2)
                self.state = 60
                self.cut()
                self.state = 65
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CutContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FinalStatePatternParser.CutContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FinalStatePatternParser.RULE_cut

     
        def copyFrom(self, ctx):
            super(FinalStatePatternParser.CutContext, self).copyFrom(ctx)



    class CutRangeContext(CutContext):

        def __init__(self, parser, ctx): # actually a FinalStatePatternParser.CutContext)
            super(FinalStatePatternParser.CutRangeContext, self).__init__(parser)
            self.copyFrom(ctx)

        def cut_number(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FinalStatePatternParser.Cut_numberContext)
            else:
                return self.getTypedRuleContext(FinalStatePatternParser.Cut_numberContext,i)

        def BINARY_OP(self, i=None):
            if i is None:
                return self.getTokens(FinalStatePatternParser.BINARY_OP)
            else:
                return self.getToken(FinalStatePatternParser.BINARY_OP, i)
        def cut_name(self):
            return self.getTypedRuleContext(FinalStatePatternParser.Cut_nameContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterCutRange"):
                listener.enterCutRange(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCutRange"):
                listener.exitCutRange(self)


    class CutBinaryContext(CutContext):

        def __init__(self, parser, ctx): # actually a FinalStatePatternParser.CutContext)
            super(FinalStatePatternParser.CutBinaryContext, self).__init__(parser)
            self.copyFrom(ctx)

        def cut_arg(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FinalStatePatternParser.Cut_argContext)
            else:
                return self.getTypedRuleContext(FinalStatePatternParser.Cut_argContext,i)

        def BINARY_OP(self):
            return self.getToken(FinalStatePatternParser.BINARY_OP, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterCutBinary"):
                listener.enterCutBinary(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCutBinary"):
                listener.exitCutBinary(self)



    def cut(self):

        localctx = FinalStatePatternParser.CutContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_cut)
        try:
            self.state = 76
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                localctx = FinalStatePatternParser.CutBinaryContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 66
                self.cut_arg()
                self.state = 67
                self.match(FinalStatePatternParser.BINARY_OP)
                self.state = 68
                self.cut_arg()
                pass

            elif la_ == 2:
                localctx = FinalStatePatternParser.CutRangeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 70
                self.cut_number()
                self.state = 71
                self.match(FinalStatePatternParser.BINARY_OP)
                self.state = 72
                self.cut_name()
                self.state = 73
                self.match(FinalStatePatternParser.BINARY_OP)
                self.state = 74
                self.cut_number()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Cut_argContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FinalStatePatternParser.Cut_argContext, self).__init__(parent, invokingState)
            self.parser = parser

        def cut_number(self):
            return self.getTypedRuleContext(FinalStatePatternParser.Cut_numberContext,0)


        def cut_name(self):
            return self.getTypedRuleContext(FinalStatePatternParser.Cut_nameContext,0)


        def function(self):
            return self.getTypedRuleContext(FinalStatePatternParser.FunctionContext,0)


        def getRuleIndex(self):
            return FinalStatePatternParser.RULE_cut_arg

        def enterRule(self, listener):
            if hasattr(listener, "enterCut_arg"):
                listener.enterCut_arg(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCut_arg"):
                listener.exitCut_arg(self)




    def cut_arg(self):

        localctx = FinalStatePatternParser.Cut_argContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_cut_arg)
        try:
            self.state = 81
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 78
                self.cut_number()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 79
                self.cut_name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 80
                self.function()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FinalStatePatternParser.FunctionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(FinalStatePatternParser.NAME, 0)

        def function_arg(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FinalStatePatternParser.Function_argContext)
            else:
                return self.getTypedRuleContext(FinalStatePatternParser.Function_argContext,i)


        def getRuleIndex(self):
            return FinalStatePatternParser.RULE_function

        def enterRule(self, listener):
            if hasattr(listener, "enterFunction"):
                listener.enterFunction(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitFunction"):
                listener.exitFunction(self)




    def function(self):

        localctx = FinalStatePatternParser.FunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self.match(FinalStatePatternParser.NAME)
            self.state = 84
            self.match(FinalStatePatternParser.T__0)
            self.state = 93
            _la = self._input.LA(1)
            if _la==FinalStatePatternParser.NAME or _la==FinalStatePatternParser.NUMBER:
                self.state = 85
                self.function_arg()
                self.state = 90
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==FinalStatePatternParser.T__2:
                    self.state = 86
                    self.match(FinalStatePatternParser.T__2)
                    self.state = 87
                    self.function_arg()
                    self.state = 92
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 95
            self.match(FinalStatePatternParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_argContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FinalStatePatternParser.Function_argContext, self).__init__(parent, invokingState)
            self.parser = parser

        def cut_name(self):
            return self.getTypedRuleContext(FinalStatePatternParser.Cut_nameContext,0)


        def cut(self):
            return self.getTypedRuleContext(FinalStatePatternParser.CutContext,0)


        def getRuleIndex(self):
            return FinalStatePatternParser.RULE_function_arg

        def enterRule(self, listener):
            if hasattr(listener, "enterFunction_arg"):
                listener.enterFunction_arg(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitFunction_arg"):
                listener.exitFunction_arg(self)




    def function_arg(self):

        localctx = FinalStatePatternParser.Function_argContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_function_arg)
        try:
            self.state = 99
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 97
                self.cut_name()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 98
                self.cut()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Cut_nameContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FinalStatePatternParser.Cut_nameContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(FinalStatePatternParser.NAME, 0)

        def object_name(self):
            return self.getTypedRuleContext(FinalStatePatternParser.Object_nameContext,0)


        def getRuleIndex(self):
            return FinalStatePatternParser.RULE_cut_name

        def enterRule(self, listener):
            if hasattr(listener, "enterCut_name"):
                listener.enterCut_name(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCut_name"):
                listener.exitCut_name(self)




    def cut_name(self):

        localctx = FinalStatePatternParser.Cut_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_cut_name)
        try:
            self.state = 107
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 101
                self.match(FinalStatePatternParser.NAME)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 102
                self.object_name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 103
                self.object_name()
                self.state = 104
                self.match(FinalStatePatternParser.T__3)
                self.state = 105
                self.match(FinalStatePatternParser.NAME)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Cut_numberContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FinalStatePatternParser.Cut_numberContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(FinalStatePatternParser.NUMBER, 0)

        def unit(self):
            return self.getTypedRuleContext(FinalStatePatternParser.UnitContext,0)


        def getRuleIndex(self):
            return FinalStatePatternParser.RULE_cut_number

        def enterRule(self, listener):
            if hasattr(listener, "enterCut_number"):
                listener.enterCut_number(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCut_number"):
                listener.exitCut_number(self)




    def cut_number(self):

        localctx = FinalStatePatternParser.Cut_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_cut_number)
        try:
            self.state = 112
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 109
                self.match(FinalStatePatternParser.NUMBER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 110
                self.match(FinalStatePatternParser.NUMBER)
                self.state = 111
                self.unit()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnitContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FinalStatePatternParser.UnitContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(FinalStatePatternParser.NAME, 0)

        def getRuleIndex(self):
            return FinalStatePatternParser.RULE_unit

        def enterRule(self, listener):
            if hasattr(listener, "enterUnit"):
                listener.enterUnit(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitUnit"):
                listener.exitUnit(self)




    def unit(self):

        localctx = FinalStatePatternParser.UnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_unit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            self.match(FinalStatePatternParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





